**FREE

/if defined( json_DEF)
/eof
/endif
/define json_DEF

///
// noxDB : JSON and XML processing
//
// noxDB is an open source framework that makes it easy to work with XML, JSON
// and SQL with one single approach - from within RPG.
//
// <h5>Node path expression</h5>
// As noxDB is an object graph you can access its nodes via a node path expression
// similar to XML XPath. noxDB supports a slash ( / ) or a dot ( . ) as a delimiter
// for the nodes.
// <p>
// <code>/customer/name</code>  is the same expression as  <code>customer.name</code>
// </p>
// The current node can be accessed by passing either '' (empty string) or
// <code>*null</code> to the function.
// <p>
// Array elements can be access by using a bracket syntax like
// <code>/customer/address[0]/street</code>.
// </p>
// The last element of an array can be retrieved by using the reserved word
// <code>UBOUND</code> like this <code>/customer/address[UBOUND]</code>.
// </p>
// Functions will do nothing if the node to work on is </code>*null</code>
// or source or destination is <code>*null</code>. If the function should
// return anything <code>*null</code> is returned.
//
// <h5>SQL functions</h5>
//
// If the function returns a boolean value indicating success or error in
// case of an error the function <em>jx_message</em> returns the SQL error
// message.
//
// <h5>CCSID</h5>
//
// To make sure that the parsers use the correct delimiters regardless of the
// CCSID at compile time of the service program always use
// <em>jx_setDelimiters(JX_DELIMITERS)</em>
// before using the parser.
//
// @author Niels Liisberg
// @version 1.0.0
// @project noxDB
// @link https://github.com/sitemule/noxDB noxDB
///


//---------------------------------------------------------------------- *
// This is the prototype for BlueSeries/IceBreak - JSON and XML parser.
// Use the JSONXML binding directory when creating your program and include
// this copybook like:
//
// H BNDDIR('JSONPARSER')
// /include jsonParser
//
// Or
//
// H BNDDIR('XMLPARSER')
// /include xmlParser
//
// Or
//
// H BNDDIR('JSONXML')
// /include jsonxml
//
// Note: Both XMLPARSER and JSONPARSER headers are autogenerated from
//       the JSONXML header. So please do not make any changes to the
//       autogenerated header files.
//
// Note: All binding directories JSONPARSER, XMLPARSER and JSONXML are
//       the same.
//---------------------------------------------------------------------- *


///
// Get delimiters
//
// Returns a pointer to the used delimiters for parsing the JSON and XML data.
// The pointer points to a data structure in the format <em>jx_DelimiterDS</em>.
//
// @return Pointer to the delimiters data structure (jx_DelimiterDS)
//
// @warning Do not deallocate the returned pointer!
///
Dcl-PR json_getDelimiters Pointer extproc(*CWIDEN : 'jx_GetDelimiters') End-PR;

///
// Set delimiters
//
// Sets the delimiters used for parsing the JSON and XML data.
// For the default delimiters see constant json_DELIMITERS.
//
// @param (input) Delimiters
///
Dcl-PR json_setDelimiters extproc(*CWIDEN : 'jx_SetDelimiters2');
  delimiters pointer value options(*string);
End-PR;

///
// Default delimiters for JSON and XML data strings.
///
Dcl-C json_DELIMITERS const('/\@[] .{}''"$');

///
// Node type UNKNOWN
///
Dcl-C json_UNKNOWN const(0);
///
// Node type OBJECT
///
Dcl-C json_OBJECT const(1);
///
// Node type ARRAY
///
Dcl-C json_ARRAY const(2);
///
// Node type EVAL
///
Dcl-C json_EVAL const(3);
///
// Node type POINTER VALUE
///
Dcl-C json_POINTER_VALUE const(4);
///
// Node type VALUE
///
Dcl-C json_VALUE const(5);
///
// Node type ROOT
///
Dcl-C json_ROOT const(6);
///
// Node type LITERAL
///
Dcl-C json_LITERAL const(16);
///
// Node type OBJECT LINK
///
Dcl-C json_OBJLINK const(17);
///
// Node type OBJECT REPLACE
///
Dcl-C json_OBJREPLACE const(18);
///
// Node type OBJECT COPY
///
Dcl-C json_OBJCOPY const(18);
///
// Node type BY CONTEXT
///
Dcl-C json_BY_CONTEXT const(19);

Dcl-C json_OBJMOVE const(2048);

// Modifiers to "add" / "or" into "parseString" and "evaluate"
//!! Type - have to be backwards compat.
//Unlink the source and move it to dest.
Dcl-C json_MOVE_MODES const(2048);
//Allow strings ints and other values to
Dcl-C json_ALLOW_PRIMITIVES const(4096);

// Combinations:
//JX_PARSE  = json_EVAL + json_MOVE_NODES
Dcl-C json_PARSE   const(2051);

/if not defined(NOXDB_COMMON_TYPES)
/define  NOXDB_COMMON_TYPES

//Merge options:
//Modifiers to "add" / "or" into "JSON_EVAL"
//Only new elements are merged - existing
//are left untouched
Dcl-C MO_MERGE_NEW const(256);
//Merge and replace only existing nodes.
Dcl-C MO_MERGE_MATCH const(512);
//Merge all: replace if it exists and
//append new nodes if not exists
Dcl-C MO_MERGE_REPLACE const(1024 );
//Move from source into destination when this is added
Dcl-C MO_MERGE_MOVE const(2048);

// 16M minus length of 4 bytes
Dcl-S VARCHAR16M varchar(16773096:4) Template;


/endif

Dcl-C json_CHILD_LIST const('[0]');



///
// Parse file
//
// Parses a JSON or XML stream file. The encodings ASCII, UTF8, 1252 and
// EBCDIC of the current job are supported.
//
// @param (input) Path to the XML or JSON file (null-terminated)
// @param (input) Options are no longer supported (deprecated)
// @return Pointer to the root node of the noxDB object tree or
//         <code>*null</code> if the file is not readable.
///
Dcl-PR json_parseFile pointer extproc(*CWIDEN : 'jx_ParseFile');
  fileName pointer value options(*string);
  options pointer value options(*string : *nopass);
End-PR;

///
// Parse string
//
// Parses a JSON or XML string.
//
// @param (input) JSON or XML string
// @param (input) Options are no longer supported (deprecated)
// @return Pointer to the root node of the noxDB object tree
///
Dcl-PR json_parseString pointer extproc(*CWIDEN : 'jx_ParseString');
  string pointer value options(*string);
  options pointer value options(*string : *nopass);
End-PR;

///
// Parse string
//
// Parses a JSON or XML string.
//
// @param (input) JSON or XML string
// @param (input) CCSID of the passed string
// @return Pointer to the root node of the noxDB object tree
///
Dcl-PR json_parseStringCcsid pointer extproc(*CWIDEN : 'jx_parseStringCcsid');
  string pointer value options(*string);
  ccsid int(10) value;
End-PR;

///
// Set decimal separator
//
// Set , or . for decimal separator.
//
// @param (input) Decimal separator character
///
Dcl-PR json_setDecPoint extproc(*CWIDEN : 'jx_SetDecPoint');
  decimalSeparator pointer value options(*string);
End-PR;

///
// Set delimiters (CCSID)
//
// Sets the delimiters for the selectors for parsing JSON and XML to
// the default values translated to the passed CCSID.
//
// @param (input) CCSID for the selectors
///
Dcl-PR json_setDelimitersByCcsid extproc(*CWIDEN : 'jx_setDelimitersByCcsid');
  ccsid int(10) value;
End-PR;


///
// Check error
//
// Checks if the last operation resulted in an error.
//
// @param (input) Node
// @return *on if the last operation resulted in an error else *off
///
Dcl-PR json_error ind extproc(*CWIDEN : 'jx_Error');
  node pointer value;
End-PR;

///
// Get error description
//
// Returns the error description for the last error.
//
// @param (input) Node (omit for last error message)
// @return Error description or <code>*blank</code> if no error occured
///
Dcl-PR json_message varchar(1024) extproc(*CWIDEN : 'jx_Message');
  node pointer value options(*nopass);
End-PR;

///
// Get error object
//
// Returns a new noxDB object tree with the boolean attribute "success" = false.
// If no parameters are passed the object will contain the attribute "msg" with
// the last error message. Otherwise the object will contain the attribute "msgId"
// with the passed message id and "msgDta" with the passed message data.
//
// @param (input) Message id
// @param (input) Message data
// @return New noxDB object tree with error message
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_close(rootNode)</em>.
///
Dcl-PR json_getMessageObject pointer extproc(*CWIDEN : 'jx_GetMessageObject');
  messageId pointer value options(*string : *nopass);
  messageData pointer value options(*string : *nopass);
End-PR;

///
// Get success object
//
// Convenience function which returns a {"success":true} object.
//
// @param (input) Message id
// @param (input) Message data
// @return New noxDB object tree with success attribute
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_close(rootNode)</em>.
///
Dcl-PR json_successTrue Pointer extproc(*CWIDEN : 'jx_SuccessTrue');
  messageId pointer value options(*string : *nopass);
  messageData pointer value options(*string : *nopass);
End-PR;

///
// Locate node
//
// Returns the node at the passed expression.
//
// @param (input) Node
// @param (input) Node path expression
// @return Located node or <code>*null</code> of no node is located at the
//         passed expression
///
Dcl-PR json_locate pointer extproc(*CWIDEN : 'jx_GetNode');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;

///
// Locate or create node
//
// Returns the node at the passed expression. If no node is located at the
// passed expression a new node will be created at the passed path expression
// and returned.
//
// @param (input) Node
// @param (input) Node path expression
// @return Node at the passed path expression (either the existing one or a new one)
///
Dcl-PR json_locateOrCreate pointer extproc(*CWIDEN : 'jx_GetOrCreateNode');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;

///
// Has node
//
// Returns <code>*on</code> if node exists.
//
// @param (input) Node
// @param (input) Node path expression
// @return <code>*on</code> if node exists else <code>*off</code>
///
Dcl-PR json_has ind extproc(*CWIDEN : 'jx_Has');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;

///
// Is node value true
//
// Returns <code>*on</code> if node exists and has non-falsy value.
// "falsy" values would be
//
// <ul>
//   <li>null</li>
//   <li>0</li>
//   <li>false</li>
//   <li>node does not exist</li>
// </ul>
//
// @param (input) Node
// @param (input) Node path expression
// @return <code>*on</code> if node value is not "falsy" else <code>*off</code>
///
Dcl-PR json_isTrue ind extproc(*CWIDEN : 'jx_IsTrue');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;

///
// Is literal
//
// Returns <code>*on</code> if the passed node is a literal.
//
// @param (input) Node
// @return <code>*on</code> if node is literale else <code>*off</code>
///
Dcl-PR json_isLiteral ind extproc(*CWIDEN : 'jx_IsLiteral');
  node pointer value;
End-PR;

///
// Is null
//
// Returns <code>*on</code> if the node does not exist or its value is
// <code>*null</code>.
//
// @param (input) Node
// @param (input) Node path expression
// @return <code>*on</code> if node does not exist or has
//         <code>*null</code> value
///
Dcl-PR json_isNull ind extproc(*CWIDEN : 'jx_IsNull');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;

///
// Is node
//
// Returns <code>*on</code> if the passed pointer is a valid node.
//
// @param (input) Node
// @return <code>*on</code> if pointer is valid node else <code>*off</code>
///
Dcl-PR json_isNode ind extproc(*CWIDEN : 'jx_isNode');
  node pointer value;
End-PR;

///
// Rename node
//
// Renames the passed node.
//
// @param (input) Node
// @param (input) New node name
///
Dcl-PR json_nodeRename extproc(*CWIDEN : 'jx_NodeRename');
  node pointer value;
  newNodeName pointer value options(*string);
End-PR;

///
// Get sibling node
//
// Returns the next sibling relative to the passed node. For objects that would
// be the next attribute on the same level. For arrays that would be the next
// element.
//
// @param (input) Node
// @return Sibling node or <code>*null</code> if there is sibling
///
Dcl-PR json_getNext pointer extproc(*CWIDEN : 'jx_GetNodeNext');
  node pointer value;
End-PR;

///
// Get child node
//
// Returns the first child node of the passed node.
//
// @param (input) Node
// @return First child node or <code>*null</code> if there is no child node
///
Dcl-PR json_getChild pointer extproc(*CWIDEN : 'jx_GetNodeChild');
  node pointer value;
End-PR;

///
// Get parent node
//
// Returns the parent node.
//
// @param (input) Node
// @return Parent node or <code>*null</code> if the passed node
//         is the root node
///
Dcl-PR json_getParent pointer extproc(*CWIDEN : 'jx_GetNodeParent');
  node pointer value;
End-PR;

///
// Set node with null value
//
// Creates a node at the passed path with the value <code>*null</code>.
// Any existing node will be replaced by this new node.
//
// @param (input) Node
// @param (input) Node path expression
// @return New node
///
Dcl-PR json_setNull pointer extproc(*CWIDEN : 'jx_SetNullByName');
  node pointer value;
  nodePath pointer value options(*string);
End-PR;


///
// Set expression as node value
//
// Sets the parsed value to the node pointed to by the passed path expression. The value will
// be parsed to a new object tree and added to the node. If the node already contains a node
// at the specified path the attributes of the nodes will be merged.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New string value
// @return Changed node
///
Dcl-PR json_setEval pointer extproc(*CWIDEN : 'jx_SetEvalByName');
  node pointer value;
  nodePath pointer value options(*string);
  value pointer value options(*string);
End-PR;

///
// Set string value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New string value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setStr pointer extproc(*CWIDEN : 'jx_SetStrByName');
  node pointer value;
  nodePath pointer value options(*string);
  value pointer value options(*string);
  nullIf ind value options(*nopass);
End-PR;

///
// Set integer value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setInt pointer extproc(*CWIDEN : 'jx_SetIntByName2');
  node pointer value;
  nodePath pointer value options(*string);
  value int(20) value;
  nullIf ind value options(*nopass);
End-PR;

///
// Create an atomic integer node
//
// @param (input) New value
// @return pointer to the new node
///

Dcl-PR json_Int pointer extproc(*CWIDEN : 'jx_Int');
  value int(20) value;
End-PR;

///
// Set decimal value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setNum pointer extproc(*CWIDEN : 'jx_SetDecByName');
  node pointer value;
  nodePath pointer value options(*string);
  value packed(30:15) value;
  nullIf ind value options(*nopass);
End-PR;

///
// Set boolean value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setBool pointer extproc(*CWIDEN : 'jx_SetBoolByName');
  node pointer value;
  nodePath pointer value options(*string);
  value ind value;
  nullIf ind value options(*nopass);
End-PR;

///
// Set date value
//
// Set the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setDate pointer extproc(*CWIDEN: 'jx_SetDateByName');
  node pointer value;
  nodePath pointer value options(*string);
  value date(*ISO) const;
  nullIf ind value options(*nopass);
End-PR;

///
// Set time value
//
// Set the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setTime pointer extproc(*CWIDEN : 'jx_SetTimeByName');
  node pointer value;
  nodePath pointer value options(*string);
  value time(*ISO) const;
  nullIf ind value options(*nopass);
End-PR;

///
// Set timestamp value
//
// Set the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @param (input) If this is *ON the value will be set to null regardless of the values
// @return Changed node
///
Dcl-PR json_setTimeStamp pointer extproc(*CWIDEN : 'jx_SetTimeStampByName');
  node pointer value;
  nodePath pointer value options(*string);
  value timestamp  const;
  nullIf ind value options(*nopass);
End-PR;

///
// Set value by pointer
//
// Set the passed value as is to the node pointed to by the passed path
// expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Value
// @param (input) <code>*on</code> = pointer points to a string and stringifies the
//        value (add double quotes),
//        <code>*off</code> = contents is already formatted JSON (default)
//        and will be added as is
// @return Changed node
//
// @info The resources of the passed value are not managed by noxDB and must
//       be freed by the caller.
///
Dcl-PR json_setPtr pointer extproc(*CWIDEN : 'jx_SetPtrByName');
  node pointer value;
  nodePath pointer value options(*string);
  value pointer value;
  stringify ind value options(*nopass);
End-PR;

///
// Set procedure pointer as value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Procedure pointer
// @param (input) Is string (deprecated)
// @return Changed node
//
// @info Procedure pointers are not intended to be serialized.
///
Dcl-PR json_setProcPtr pointer extproc(*CWIDEN : 'jx_SetPtrByName');
  node pointer value;
  nodePath pointer value options(*string);
  value pointer(*proc) value;
  isString ind value options(*nopass);
End-PR;

///
// Data-Into Parser
//
// This implemenation of a <em>data-into</em> parser takes a noxDB object tree
// and maps it to a data structure.
//
// @param (input) Node to be mapped to a data structure
// @return Procedure pointer of the data-into parser
///
Dcl-PR json_dataInto pointer(*proc) extproc(*CWIDEN : 'jx_dataInto');
  node pointer value;
End-PR;

///
// Data-Gen Generator
//
// This implementation of a <em>data-gen</em> generator takes a data structure
// and maps it to a noxDB object tree. The noxDB object tree will be created by
// this function an does not need to exist.
//
// @param (output) noxDB object tree (output parameter) Note: This is passed by reference pointer to noxDB tree
// @param (input) options, check IBM documentation for data-gen for possible options
// @return Procedure pointer of the data-gen generator function
//
// @info The noxDB object tree returned by this procedure through the output
//       parameter needs to be freed by calling <em>jx_delete(node)</em> by the
//       user of this function.
///
Dcl-PR json_dataGen pointer(*proc) extproc(*CWIDEN : 'jx_dataGen');
  node    pointer; // Note: This is passed by reference pointer to noxDB tree
  options pointer value options(*string : *nopass);
End-PR;

///
// Set value
//
// Sets the passed value to the node pointed to by the passed path expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Value (default: empty string)
// @param (input) Node type (see node type constants, default json_UNKNOWN)
// @return Changed node
///
Dcl-PR json_setValue Pointer extproc(*CWIDEN: 'jx_SetValueByName');
  node pointer value;
  nodePath pointer value options(*string);
  value pointer value options(*string : *nopass);
  nodeType uns(5) value options(*nopass);
End-PR;

///
// Get string value
//
// Returns the value of the passed node.
//
// @param (input) Node
// @param (input) Default value
// @return String value or the default value (or an empty string) if the node
//         does not exist
///
Dcl-PR json_getValueStr varchar(32767) extproc(*CWIDEN : 'jx_GetNodeValueVC');
  node pointer value;
  defaultValue pointer value options(*string : *nopass);
End-PR;

///
// Get decimal value
//
// Returns the value of the passed node.
//
// @param (input) Node
// @param (input) Default value
// @return Decimal value or the default value (or 0) if the node does not exist
///
Dcl-PR json_getValueNum packed(30:15) extproc(*CWIDEN : 'jx_GetNodeValueNum');
  node pointer value;
  defaultValue packed(30:15) value options(*nopass);
End-PR;

///
// Get integer value
//
// Returns the value of the passed node.
//
// @param (input) Node
// @param (input) Default value
// @return Integer value or the default value (or 0) if the node does not exist
///
Dcl-PR json_getValueInt int(20) extproc(*CWIDEN : 'jx_GetNodeValueInt');
  node pointer value;
  defaultValue int(20) value options(*nopass);
End-PR;

///
// Get pointer value
//
// Returns the value of the passed node.
//
// @param (input) Node
// @param (input) Default value
// @return Pointer value or the default value (or *null) if the node does not
//         exist
///
Dcl-PR json_getValuePtr pointer extproc(*CWIDEN : 'jx_GetNodeValuePtr');
  node pointer value;
  defaultValue pointer value options(*string : *nopass);
End-PR;

Dcl-PR json_getValueProcPtr pointer(*proc) extproc(*CWIDEN : 'jx_GetNodeValuePtr');
  node pointer value;
  defaultValue pointer value options(*nopass);
End-PR;


///
// Get node name
//
// Returns the name of the node.
//
// @param (input) Node
// @return Node name
///
Dcl-PR json_getName varchar(32767) extproc(*CWIDEN : 'jx_GetNodeNameVC');
  node pointer value;
End-PR;

///
// Get path expression of node
//
// Returns the node path expression for the passed node, f. e. /item/price .
//
// @param (input) Node
// @param (input) Node path element delimiter (for example . or /)
// @return Node path expression
///
Dcl-PR json_getNameAsPath varchar(32767) extproc(*CWIDEN :'jx_GetNodeNameAsPath');
  node pointer value;
  delimiter char(1) value;
End-PR;

///
// Get node type
//
// Returns the node type of the passed node.
//
// @param (input) Node
// @return Node type constant
///
Dcl-PR json_nodeType int(5) extproc(*CWIDEN : 'jx_GetNodeType');
  node pointer value;
End-PR;

///
// Node Option Format : XML Serializer Default Format
///
Dcl-C json_FORMAT_DEFAULT const(0);
///
// Node Option Format : XML Serializer CDATA Format
///
Dcl-C json_FORMAT_CDATA const(1);

///
// Set node options
//
// Sets the node format options which will among other things affect how the
// node will be output by the serializers.
//
// @param (input) Node
// @param (input) Format option (JX_FORMAT_DEFAULT, json_FORMAT_CDATA)
// @return Passed node (first parameter)
///
Dcl-PR json_setNodeOptions pointer extproc(*CWIDEN : 'jx_SetNodeOptions');
  node pointer value;
  format int(5) value;
End-PR;

///
// Get string value by expression
//
// Returns the string value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression (default: current node)
// @param (input) Default value
// @return String value or the default value if the node does not exist
///
Dcl-PR json_getStr varchar(32767) extproc(*CWIDEN : 'jx_GetValueVC');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue pointer value options(*string : *nopass);
End-PR;

///
// Join array nodes to string
//
// Joins the values of all <em>array</em> nodes to a string.
// <br><br>
// [12.345, "-", 6, 7, true, { "id" : 358 }] will result in the string
// 12.345-67true . Any object nodes will be ignored.
//
// @param (input) Node
// @param (input) Node path expression to the array node (default: current node)
// @param (input) Default value
// @param (input) Delimiter variable length string
// @return String with all values from the array nodes
///
Dcl-PR json_getStrJoin varchar(32767) extproc(*CWIDEN : 'jx_GetStrJoinVC');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue pointer value options(*string : *nopass);
  delimiter pointer value options(*string : *nopass);
End-PR;

///
// Get decimal value by expression
//
// Returns the decimal value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression (default: current node)
// @param (input) Default value
// @return Decimal value or the default value if the node does not exist
///
Dcl-PR json_getNum packed(30:15) extproc(*CWIDEN : 'jx_GetValueNum');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue packed(30:15) value options(*nopass);
End-PR;

///
// Get integer value by expression
//
// Returns the integer value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression (default: current node)
// @param (input) Default value
// @return Integer value or the default value if the node does not exist
///
Dcl-PR json_getInt int(20) extproc(*CWIDEN : 'jx_GetValueInt');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue int(20) value options(*nopass);
End-PR;

///
// Get boolean value by expression
//
// This is equivalent to <em>jx_isTrue</em> but with additional support
// for a default value.
//
// @param (input) Node
// @param (input) Node path expression (default: current node)
// @param (input) Default value
// @return Node value is not "falsy" or
//         the default value if the node does not exist
///
Dcl-PR json_getBool ind extproc(*CWIDEN : 'jx_GetValueBool');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue ind value options(*nopass);
End-PR;

///
// Get date value by expression
//
// Returns the date value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Default value
// @return Date value or the default value if the node does not exist
///
Dcl-PR json_getDate date(*ISO) extproc(*CWIDEN : 'jx_GetValueDate');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue date(*ISO) value options(*nopass);
End-PR;

///
// Get time value by expression
//
// Returns the time value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Default value
// @return Time value or the default value if the node does not exist
///
Dcl-PR json_getTime time(*ISO)  extproc(*CWIDEN : 'jx_GetValueTime');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue time(*ISO) value options(*nopass);
End-PR;

///
// Get timestamp value by expression
//
// Returns the timestamp value of the node pointed to by the passed expression.
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) Default value
// @return Timestamp value or the default value if the node does not exist
///
Dcl-PR json_getTimeStamp timestamp extproc(*CWIDEN : 'jx_GetValueTimeStamp');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
  defaultValue timestamp value options(*nopass);
End-PR;


///
// Copy node value
//
// Copies the value of a node to an new or existing node.
// <br><br>
// If the source node is an object or array (type json_ARRAY or json_OBJECT) the
// object or array will be cloned to the destination value.
// <br><br>
// If the source node does not exist nothing will be copied and <code>*null</code>
// is returned.
// <br><br>
// If the source or destination is relative to the node the node path expression
// can be used to specify the location.
//
// @param (output) Destination node
// @param (output) Destination node path expression
// @param (input) Source node
// @param (input) Source node path expression
// @return New node or <code>*null</code> if the operation could not be executed
///
Dcl-PR json_copyValue pointer extproc(*CWIDEN : 'jx_CopyValue');
  destNode pointer value;
  destName pointer value options(*string);
  sourceNode pointer value;
  sourceName pointer value options(*string);
End-PR;

///
// Move node value
//
// Moves the value of a node to an new or existing node.
// <br><br>
// If the source node is an object or array (type json_ARRAY or json_OBJECT) the
// object or array will be moved ( with children) to the destination value.
// <br><br>
// If the source node does not exist nothing will be moved and <code>*null</code>
// is returned.
// <br><br>
// If the source or destination is relative to the node the node path expression
// can be used to specify the location.
//
// @param (output) Destination node
// @param (output) Destination node path expression
// @param (input) Source node
// @param (input) Source node path expression
// @return New node (Destination) or <code>*null</code> if the operation could not be executed
///
Dcl-PR json_moveValue pointer extproc(*CWIDEN : 'jx_MoveValue');
  destNode pointer value;
  destName pointer value options(*string);
  sourceNode pointer value;
  sourceName pointer value options(*string);
End-PR;


///
// Copy node
//
// Adds a copy of an existing node to the noxDB object tree.
// <br><br>
// The reference location indicates where the new node will be added relative
// to the passed node. Possible value are
// <ul>
//   <li>JX_FIRST_CHILD</li>
//   <li>JX_LAST_CHILD</li>
//   <li>JX_BEFORE_SIBLING</li>
//   <li>JX_AFTER_SIBLING</li>
// </ul>
//
// @param (output) Node
// @param (input) Source node
// @param (input) Reference location
// @return New node or <code>*null</code> if source or destination is
//         <code>*null</code>.
///
Dcl-PR json_nodeCopy pointer extproc(*CWIDEN : 'jx_NodeCopy');
  node pointer value;
  sourceNode pointer value;
  referenceLocation int(10) value;
End-PR;

///
// Insert node existing root node
//
// Moves an existing root node to the noxDB object tree.
// <br><br>
//
// The reference location indicates where the new node will be moved into relative
// to the passed node. Possible value are
// <ul>
//   <li>JX_FIRST_CHILD</li>
//   <li>JX_LAST_CHILD</li>
//   <li>JX_BEFORE_SIBLING</li>
//   <li>JX_AFTER_SIBLING</li>
// </ul>
//
// @param (output) Node
// @param (input) Source node
// @param (input) Reference location
// @return the source node  <code>*null</code> if source or destination is
//         <code>*null</code>.
///
Dcl-PR json_nodeInsert  pointer extproc(*CWIDEN : 'jx_nodeInsert');
  node pointer value;
  sourceNode pointer value;
  referenceLocation int(10) value;
End-PR;


///
// Node Copy - Reference location : first child
///
Dcl-C json_FIRST_CHILD const(1);
///
// Node Copy - Reference location : last child
///
Dcl-C json_LAST_CHILD const(2);
///
// Node Copy - Reference location : before sibling
///
Dcl-C json_BEFORE_SIBLING const(3);
///
// Node Copy - Reference location : after sibling
///
Dcl-C json_AFTER_SIBLING const(4);

///
// Clone node
//
// Deep clone of the passed node.
//
// @param (input) Node
// @return Clone of the passed node
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_nodeClone pointer extproc(*CWIDEN : 'jx_NodeClone');
  node pointer value;
End-PR;

///
// Add node
//
// Adds new node to object tree.
//
// @param (output) Node
// @param (input) Reference location (see Node Copy - Reference locations)
// @param (input) New node name
// @param (input) New node value (value or expression)
// @param (input) New node type
// @return New node
///
Dcl-PR json_nodeAdd Pointer extproc(*CWIDEN : 'jx_NodeAdd');
  node pointer value;
  referenceLocation int(10) value;
  name pointer value options(*string);
  value pointer value options(*string);
  type uns(5) value;
End-PR;

///
// Delete node
//
// The passed node and all child nodes are remove from the noxDB object tree.
// The memory is freed and the pointer is set to <code>*null</code>.
//
// @param (input) Node (<code>*null</code> will be ignored)
///
Dcl-PR json_nodeDelete extproc(*CWIDEN : 'jx_NodeDelete');
  node pointer value;
End-PR;

///
// Delete node
//
// Alias for <em>jx_nodeDelete</em>.
//
// @param (input) Node (<code>*null</code> will be ignored)
///
Dcl-PR json_delete extproc(*CWIDEN : 'jx_NodeDelete');
  node pointer value;
End-PR;


///
// Unlink node from tree
//
// Unlinks the passed node from the tree. The unlinked node will be promoted as
// a new root node and functions as a new object tree.
//
// @param (input) Node (<code>*null</code> will be ignored)
// @return Unlinked node
//
// @info The unlinked node is no longer connected to its former object tree
//       and its resources must be freed with a call to
//       <code>jx_close(unlinkedNode)</code>.
///
Dcl-PR json_nodeUnlink pointer extproc(*CWIDEN : 'jx_NodeUnlink');
  node pointer value;
End-PR;

///
// Sanitize node
//
// Nodes with <code>null</code> values or no values at all will be removed from
// the noxDB object tree.
//
// @param (input/output) Node
///
Dcl-PR json_nodeSanitize extproc(*CWIDEN : 'jx_NodeSanitize');
  node pointer value;
End-PR;

///
// Create checksum of tree
//
// Creates a checksum of all node names and values. Names and values
// of <code>*null</code> are ignored.
//
// @param (input) Node
// @return Checksum
///
Dcl-PR json_nodeCheckSum uns(10) extproc(*CWIDEN : 'jx_NodeCheckSum');
  node pointer value;
End-PR;

///
// Create object tree
//
// Creates a new noxDB object tree.
//
// @param (input) The new object node will be appended to this node.
// @return New object tree or new node if the destination is passed
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_newObject pointer extproc(*CWIDEN : 'jx_NewObject');
  destination pointer value options(*nopass);
End-PR;

Dcl-PR json_Obj pointer extproc(*CWIDEN : 'jx_Object');
  p00 pointer value options(*nopass:*string);
  p01 pointer value options(*nopass:*string);
  p02 pointer value options(*nopass:*string);
  p03 pointer value options(*nopass:*string);
  p04 pointer value options(*nopass:*string);
  p05 pointer value options(*nopass:*string);
  p06 pointer value options(*nopass:*string);
  p07 pointer value options(*nopass:*string);
  p08 pointer value options(*nopass:*string);
  p09 pointer value options(*nopass:*string);
End-PR;

///
// Create array
//
// Creates a new array.
//
// @param (input) The new array node will be appended to this node.
// @return New array or new node if the destination is passed
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_newArray pointer extproc(*CWIDEN : 'jx_NewArray');
  node pointer value options(*nopass);
End-PR;

Dcl-PR json_Arr pointer extproc(*CWIDEN : 'jx_Array');
  p00 pointer value options(*nopass:*string);
  p01 pointer value options(*nopass:*string);
  p02 pointer value options(*nopass:*string);
  p03 pointer value options(*nopass:*string);
  p04 pointer value options(*nopass:*string);
  p05 pointer value options(*nopass:*string);
  p06 pointer value options(*nopass:*string);
  p07 pointer value options(*nopass:*string);
  p08 pointer value options(*nopass:*string);
  p09 pointer value options(*nopass:*string);
End-PR;

///
// Push node into array
//
// Appends the passed node/value to the array. The node can either be an noxDB
// object tree or a string. If a string is passed and it is a JSON expression
// (starting with { or [) it will be parsed else the string will be appended to
// the array as it.
//
// @param (output) Array
// @param (input) Node to be appended to the end of the array
// @param (input) Push operation mode (JX_MOVE_UNLINK (default) or json_COPY_CLONE)
// @return New node added to the end of the array
///
Dcl-PR json_arrayPush pointer extproc(*CWIDEN : 'jx_ArrayPush');
  array pointer value;
  node pointer value options(*string);
  pushMode uns(5) value options(*nopass);
End-PR;

///
// Array Operation : Unlink and move
///
Dcl-C json_MOVE_UNLINK const(0);
///
// Array Operation : copy
///
Dcl-C json_COPY_CLONE const(1);

///
// Push array nodes into array
//
// Appends all nodes from one array to another array.
//
// @param (output) Destination array (to)
// @param (input) Source array (from)
// @param (input) Push operation mode (JX_MOVE_UNLINK (default) or json_COPY_CLONE)
// @return Destination array
///
Dcl-PR json_arrayAppend pointer extproc(*CWIDEN : 'jx_ArrayAppend');
  destination pointer value;
  source pointer value options(*string);
  pushMode uns(5) value options(*nopass);
End-PR;

///
// Slice array
//
// returns a sub-array from an array. The node specified on the "to" parameter is
// included .
//
// @param (input) Array or JSON array string
// @param (input) From index (1-based)
// @param (input) To index (-1 = all nodes from "from" index to till the end)
// @param (input) Copy operation mode. json_MOVE_UNLINK (default) removes the "sliced"
//        nodes from the source array. json_COPY_CLONE leaves the nodes in
//        the source array and just copies the nodes to the new array.
// @return New array with the "sliced" nodes
///
Dcl-PR json_arraySlice pointer extproc(*CWIDEN : 'jx_ArraySlice' );
  array pointer value options(*string);
  from int(10) value;
  to int(10) value;
  copyMode uns(5) value options(*nopass);
End-PR;

///
// Sort array
//
// Sorts the array nodes "in place".
//
// @param (input/output) Array
// @param (input) Object attributes to compare
// @param (input) Compare options (0 = use JSON numeric (default) or json_USE_LOCALE)
// @return Sorted array
///
Dcl-PR json_arraySort pointer extproc(*CWIDEN : 'jx_ArraySort');
  array pointer value;
  keyNames pointer value options(*string) ;
  compareOptions uns(5) value options(*nopass);
End-PR;

///
// Convert an array of objects OR an object into a simple array
//
// @param (input/output) Array of objects or an object
// @param (input) Copy operation mode. json_MOVE_UNLINK (default) removes the "input array of object"
//        node. json_COPY_CLONE leaves the node
// @return New array with the "converted" nodes
///
Dcl-PR json_arrayConvertList pointer extproc(*CWIDEN : 'jx_ArrayConvertList' );
  array pointer value options(*string);
  copyMode uns(5) value options(*nopass);
End-PR;


///
// Array Sort : array nodes comparison using current locale
///
Dcl-C json_USE_LOCALE const(1);

///
// Lookup value
//
// Returns the first node which matches the passed expression.
//
// @param (input) Array or object
// @param (input) Search value
// @param (input) Case sensitivity (JX_SAME_CASE or json_IGNORE_CASE)
// @return First node which matches the expression else <code>*null</code>
//
// @info The search will not be done recursivly. Only the first level (depth)
//       of the node's content will be evaluated.
///
Dcl-PR json_lookupValue pointer extproc(*CWIDEN : 'jx_lookupValue');
  node pointer value;
  searchValue pointer value options(*string);
  case uns(5) value options(*nopass);
End-PR;

///
// Array Value Lookup : Case sensitive
///
Dcl-C json_SAME_CASE const(0);
///
// Array Value Lookup : Case insensitive
///
Dcl-C json_IGNORE_CASE const(1);

///
// Get length
//
// Returns the number of nodes in an array or object.
//
// @param (input) Node
// @return Number of nodes or -1 if the passed node is no array or
//         object node type.
///
Dcl-PR json_getLength int(10) extproc(*CWIDEN : 'jx_getLength');
  array pointer value;
End-PR;

///
// Merge node
//
// Merges all nodes from the <em>source</em> object into the
// <em>destination</em> object tree.
//
// @param (input/output) Destination
// @param (input) Source
// @param (input) Merge option
// @deprecated Replaced by json_mergeObjects
///
Dcl-PR json_merge extproc(*CWIDEN : 'jx_NodeMerge');
  destination pointer value;
  source pointer value;
  type uns(5) value options(*nopass);
End-PR;

///
// Merge Option : Do not replace nodes
///
Dcl-C json_DONTREPLACE const(0);
///
// Merge Option : Replace existing nodes
///
Dcl-C json_REPLACE const(1);

///
// Merge objects
//
// Merges all nodes from the <em>source</em> object into the <em>destination</em>
// object tree. Objects are recursively merged. The nodes (entries) of arrays
// are not merged. The whole array is either replaced or retained depending on
// the options parameter.
// <br><br>
// The options parameter determines what happens if a node with the same name
// exists in both object trees.
// Default is MO_MERGE_NEW which means that only new nodes from the source and copied
// Optional: can be ORED / + with MO_MERGE_MOVE to move the source nodes instead of copying them.
//
// @param (input/output) Destination object tree
// @param (input) Source object tree
// @param (input) Merge option:  MO_MERGE_NEW,MO_MERGE_MATCH,MO_MERGE_REPLACE ( ORED + MO_MERGE_MOVE )

///
Dcl-PR json_mergeObjects extproc(*CWIDEN : 'jx_MergeObjects');
  destination pointer value;
  source pointer value;
  mergeOption uns(5) value;
End-PR;

///
// Move object into
//
// Moves a <em>source</em> object into a <em>destination</em> object. If the
// source object is no root object it will be unlinked from its current object
// tree. The source object will be available in the destination object under
// the passed name.
// <br><br>
// If no name is passed ('' or *null) then the source object replaces the
// destination object in its current position in the object tree.
// <br><br>
// Any existing node with the passed name in the destination object will be
// replaced by the source object.
//
// @param (input/output) Destination object
// @param (input) New node name
// @param (input) Source object
// @return Source object
//
// @info The <em>name</em> parameter is <b>no</b> node path expression!
//       It is the concrete name of the source object in the destination
//       object.
///
Dcl-PR json_moveObjectInto pointer extproc(*CWIDEN : 'jx_NodeMoveInto');
  destination pointer value;
  name pointer value options(*string);
  source pointer value;
End-PR;

///
// Move node into object tree
//
// Moves a node into an existing object tree.
//
// @param (output) Destination node
// @param (input) Source node
// @param (input) Destination location (see Node Copy - Reference locations  )
// @return Destination node
//
// @info The source node pointer will be <code>*null</code> after this function
//       call.
///
Dcl-PR json_documentInsert pointer extproc(*CWIDEN : 'jx_documentInsert');
  destination pointer value;
  source pointer;
  location int(10) value;
End-PR;

///
// Dump object tree
//
// Outputs the object tree of the passed node via <em>printf</em>.
//
// @param (input) Node
///
Dcl-PR json_dump extproc(*CWIDEN : 'jx_Dump');
  node pointer value;
End-PR;

///
// Write JSON to stream file
//
// Writes the object tree as a JSON string to a stream file in the IFS.
//
// @param (input) Node
// @param (input) IFS File name
// @param (input) CCSID of the output file
// @param (input) <code>*off</code> = output will be pretty printed else
//        <code>*on</code> (default)
// @param (input) Object tree node with options (not supported atm)
//
// @info By default a BOM will be prepended for unicode data. If no BOM is
//       needed then the CCSID should be stated as a negative number, like
//       -1208 for UTF-8.
// @info Any existing file will be overwritten.
// @info The trimming of the output refers only to the formatting / pretty
//       printing of the document. Any leading or trailing spaces in any
//       values will be preserved.
///
Dcl-PR json_writeJsonStmf extproc(*CWIDEN : 'jx_WriteJsonStmf');
  node pointer value;
  fileName pointer value options(*string);
  ccsid int(10) value;
  trimOption ind value options(*nopass);
  options pointer value options(*string : *nopass);
End-PR;

///
// To JSON string
//
// Returns the passed object tree as a JSON string.
//
// @param (input) Node
// @return Object tree representation as a JSON string
///
Dcl-PR json_asJsonText varchar(32767) extproc(*CWIDEN : 'jx_AsJsonText');
  node pointer value;
End-PR;

///
// To JSON string long varchar
//
// Returns the passed object tree as a JSON string.
//
// @param (input) Node
// @return Object tree representation as a JSON string
///
Dcl-PR json_AsJsonText16M Like(VARCHAR16M)  rtnparm
        extproc(*CWIDEN : 'jx_AsJsonText16M');
  node pointer value;
End-PR;

///
// String quote - escapes quotes into double quotes and add leading and trailing
// Courtesy function to avoid SQL injection attacks
//
// Returns quote escaped string
//
// @param (input) String to be quoted
// @return Quoted string
///
Dcl-PR json_strQuote  varchar(32767)  rtnparm
        extproc(*CWIDEN : 'jx_strQuote');
  stringToQuote varchar(32767) const  options(*varsize);
End-PR;


///
// To JSON string (Buffer)
//
// Places the passed object tree as a JSON string into the passed buffer.
//
// @param (input) Node
// @param (output) Buffer
// @param (input) Buffer length (in bytes)
// @return Length of the serialized JSON string
//
// @info If no buffer length is passed the procedure will assume the default
//       buffer size which is about 2GB, see MEMMAX defined in memUtil.h.
///
Dcl-PR json_asJsonTextMem uns(10) extproc(*CWIDEN : 'jx_AsJsonTextMem');
  node pointer value;
  buffer pointer value;
  bufferSize uns(10) value options(*nopass);
End-PR;

///
// Write XML to stream file
//
// Writes the object tree as a XML string to a stream file in the IFS.
// A XML header including the used encoding will be written at the
// start of the XML file.
//
// @param (input) Node
// @param (input) IFS File name
// @param (input) CCSID of the output file
// @param (input) <code>*off</code> = output will be pretty printed else
//        <code>*on</code> (default)
// @param (input) Object tree node with options (not supported atm)
//
// @info Following CCSIDs are supported: 1200, 1208, 819, 1252. Every
//       other CCSID defaults to 1252.
// @info CCSIDs 1200 and 1208 will get a BOM prepended to the actual XML.
// @info Any existing file will be overwritten.
// @info The trimming of the output refers only to the formatting / pretty
//       printing of the document. Any leading or trailing spaces in any
//       values will be preserved.
///
Dcl-PR json_writeXmlStmf extproc(*CWIDEN : 'jx_WriteXmlStmf');
  node pointer value;
  fileName pointer value options(*string);
  ccsid int(10) value;
  trim ind value;
  options pointer value options(*string : *nopass);
End-PR;

///
// To XML string
//
// Returns the passed object tree as a XML string.
//
// @param (input) Node
// @return Object tree representation as a XML string
///
Dcl-PR json_asXmlText varchar(32767) extproc(*CWIDEN : 'jx_AsXmlText');
  node pointer value;
End-PR;

///
// To XML string (Buffer)
//
// Places the passed object tree as a XML string into the passed buffer.
//
// @param (input) Node
// @param (output) Buffer
// @return Length of the serialized XML string
//
// @warning Buffer length is not checked.
///
Dcl-PR json_asXmlTextMem uns(10) extproc(*CWIDEN : 'jx_AsXmlTextMem');
  node pointer value;
  buffer pointer value;
End-PR;

///
// Create stream
//
// Creates a stream object to be used by the noxDB serializers.
//
// @param (input) Node
// @return Stream object
///
Dcl-PR json_stream pointer extproc(*CWIDEN : 'jx_Stream');
  node pointer value;
End-PR;

///
// Write CSV to stream file
//
// Writes the object tree as a CSV (character seperated values) string to a
// stream file in the IFS.
// <br><br>
// The options parameter is a noxDB object tree with following values:
// <ul>
//   <li>delimiter : value separator</li>
//   <li>decPoint : decimal point character</li>
//   <li>headers : true = column headers will be written</li>
// </ul>
//
// @param (input) Node
// @param (input) File name (either a literal or null-terminated in a variable)
// @param (input) CCSID of the output file
// @param (input) <code>*on</code> = output will be trimmed else <code>*off</code>
// @param (input) Options
//
// @info CCSIDs 1200 and 1208 will get a BOM prepended to the actual values.
// @info Any existing file will be overwritten.
///
Dcl-PR json_writeCsvStmf extproc(*CWIDEN : 'jx_WriteCsvStmf');
  node pointer value;
  fileName pointer value options(*string);
  ccsid int(10) value;
  trim ind value;
  options pointer value options(*string : *nopass);
End-PR;

///
// Delimiter template - special/reserved characters used in XML and JSON
///
Dcl-DS json_DelimiterDS based(prototype_only) qualified;
  Slash          Char(1);
  BackSlash      Char(1);
  Masterspace    Char(1);
  BraBeg         Char(1);
  BraEnd         Char(1);
  Blank          Char(1);
  Dot            Char(1);
  CurBeg         Char(1);
  CurEnd         Char(1);
  Apos           Char(1);
  Quot           Char(1);
End-DS;

///
// Iterator template - this data structure holds state of the iteration,
// see json_forEach. Thus multiple iterators can be used on the same object
// tree at the same time. All properties are read-only except "break".
//
// <ul>
//   <li>root : node of the origin of the iterator</li>
//   <li>this : current node in the list</li>
//   <li>isList : will be *ON if the iterator is working in the list</li>
//   <li>isFirst : will be *ON only at the first element</li>
//   <li>isLast : will be *ON only at the last element</li>
//   <li>isRecursive : will be on in a recursion </li>
//   <li>comma : Will be ',' as long there are more elements in the list </li>
//   <li>count : current element index (starting at 1)</li>
//   <li>length : number of elements</li>
//   <li>size  : Size of the iterator object ( internal use only)</li>
//   <li>listArr :Pointer to temp array of elms for recursive lists ( internal use only)</li>
//   <li>break : set this to *ON to terminate the loop, and free up memory</li>
// </ul>
///
Dcl-DS json_iterator based(prototype_only) qualified;
  root           Pointer; // Node of the origin of the iterator
  this           Pointer; // Current node in the list
  isList         Ind; // Will be *ON if the iterator is working in the list
  isFirst        Ind; // Will be *ON only at the first element
  isLast         Ind; // Will be *ON only at the last element
  isRecursive    Ind; // Will be on in a recursion
  comma          Varchar(1); // Will be ',' as long there are more in the list
  count          Int(10); // Current element number
  length         Int(10); // Number of elements
  size           Int(10); // Size of the iterator object ( internal use only)
  listArr        Pointer; // Pointer to temp array of elms for recursive lists ( internal use only)
  break          Ind; //Set  this to *ON to terminate loop
  filler         Char(64); // Extra space for the future
End-DS;

///
// Create iterator
//
// Creates a new iterator instance on the passed object tree.
//
// @param (input) Node
// @param (input) Node path expression to the node which child elements will be iterated
// @return Iterator instance
//
// @info This iterator should be used with the function <em>jx_forEach</em>
///
Dcl-PR json_setIterator likeds( json_iterator) extproc(*CWIDEN : 'jx_SetIterator');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
End-PR;

///
// Create recursive iterator
//
// Creates a new iterator instance on the passed object tree. This iterator
// will not stop iterating when the end is reached but will restart at the
// given start node.
//
// @param (input) Node
// @param (input) Node path expression to the node which child elements will be iterated
// @return Iterator instance
///
Dcl-PR json_setRecursiveIterator likeds( json_iterator)
    extproc(*CWIDEN : 'jx_SetRecursiveIterator');
  node pointer value;
  nodePath pointer value options(*string : *nopass);
End-PR;

///
// Iterate
//
// Iterates through the child nodes of the iterator start node. The entries
// are either the entries of an array or the keys of an object depending on
// the start node.
// <br><br>
// The current value (iterator.this) and some additional information (isFirst,
//  isLast, ...) can be retrieved from the iterator data structure.
// <br><br>
// The iteration can be interrupted either by leaving the loop or by setting
// iterator.break to *on.
//
// @param (input) Iterator
// @return *on if there is another entry , *off if the iteration ended
///
Dcl-PR json_forEach ind extproc(*CWIDEN : 'jx_ForEach');
  iterator likeds( json_iterator);
End-PR;


//
// XML attributes
//

///
// Get attribute value from node
//
// Returns the attribute value of the attribute from the passed node.
//
// @param (input) Node
// @param (input) Attribute name
// @param (input) Default value
// @return Attribute value or default value if no attriute exists
///
Dcl-PR json_getNodeAttrValue varchar(32767)
                           extproc(*CWIDEN : 'jx_GetNodeAttrValueVC');
  node pointer value;
  name pointer value options(*string);
  defaultValue pointer value options(*string : *nopass);
End-PR;

///
// Set attribute on node
//
// Sets the attribute on the passed node. Any existing attribute value
// will be replaced.
//
// @param (input) Node
// @param (input) Attribute name
// @param (input) Attribute value
//
// @info Attributes will be omitted in JSON output.
///
Dcl-PR json_setNodeAttrValue extproc(*CWIDEN : 'jx_SetNodeAttrValue');
  node pointer value;
  name pointer value options(*string);
  value pointer value options(*string);
End-PR;

///
// Get attribute value
//
// Returns the value from the passed attribute.
//
// @param (input) Attribute
// @param (input) Default value
// @return Attribute value or default value if the attribute has no value
///
Dcl-PR json_getAttrValue varchar(32767) extproc(*CWIDEN : 'jx_GetAttrValueVC');
  attribute pointer value;
  defaultValue pointer value options(*string : *nopass);
End-PR;

///
// Append new attibute
//
// Appends a new attribute with the passed name and value to the attribute
// list which the passed attribute is part of. Duplicate attribute names
// are valid.
//
// @param (input) Attribute
// @param (input) Name
// @param (input) Value
///
Dcl-PR json_setAttrValue extproc(*CWIDEN : 'jx_SetNodeAttrValue');
  attribute pointer value;
  name pointer value options(*string);
  value pointer value options(*string);
End-PR;

///
// Get first attribute
//
// Returns the first attribute of the attribute list of the passed node.
// This can be used for iterating over the attributes of a node in
// conjunction with the function <em>jx_getAttrNext</em>.
//
// @param (input) Node
// @return First attribute or <code>*null</code> if the node has no
//         attributes.
///
Dcl-PR json_getAttrFirst pointer extproc(*CWIDEN : 'jx_GetAttrFirst');
  node pointer value;
End-PR;

///
// Get next attribute
//
// Returns the next attribute of the attribute list.
//
// @param (input) Attribute
// @return Next attribute or <code>*null</code> if there are no more attributes
///
Dcl-PR json_getAttrNext pointer extproc(*CWIDEN : 'jx_GetAttrNext');
  attribute pointer value;
End-PR;

///
// Get attribute name
//
// Returns the name of the passed attribute.
//
// @param (input) Attribute
// @return Attribute name
///
Dcl-PR json_getAttrName varchar(32767) extproc(*CWIDEN : 'jx_GetAttrNameVC');
  attribute pointer value;
End-PR;

//
// XML attributes end
//


///
// Clear array / object
//
// Clears the contents of an array or object (deletes all child nodes).
//
// @param (input) Node
///
Dcl-PR json_clear extproc(*CWIDEN : 'jx_Clear');
  node pointer value;
End-PR;

///
// Close object graph
//
// Frees all resources allocated by this object graph.
//
// @param (input) Node
//
// @info The passed node does not necessarily has to be the root node of the
//       graph. Any node of the graph will suffice.
///
Dcl-PR json_close extproc(*CWIDEN : 'jx_Close');
  node pointer;
End-PR;


///
// Programs and procedures : Call program
//
// Call ILE program compiled with ctl-opt pgminfo(*PCML:*MODULE)
//
// @param (input) Library where the ILE program exists or *LIBL
// @param (input) Program name of the ILE program
// @param (input) parms   input parameters for the program in a json object mached by names
// @param (input) options formating and runtime options AND/added togeter
// @return noxDB object tree with output from the program call
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///

Dcl-PR json_CallProgram pointer extproc(*CWIDEN : 'jx_CallProgram');
  library        char(10) const;
  program        char(10) const;
  parms          pointer  value  options(*string:*nopass) ;
  formatOptions  int(10) value options(*nopass) ;
End-PR;


///
// Programs and procedures : Load program as procedure pointer
//
//
// @param (input) Library where the ILE program exists or *LIBL
// @param (input) Program name of the ILE program
// @return procedure pointer or null and wrap it in a MONITOR
//
///
Dcl-PR json_LoadProgram pointer(*proc) extproc(*CWIDEN : 'jx_loadProgram');
  library        char(10) const;
  program        char(10) const;
End-PR;

///
// Programs and procedures : Call program  - lo level
// @param (input) procedure pointer to the program  to call
// @param (input) parms pointer to array of addresse to parameters to pass to the procedure
// @param (input) numberOfParms number of parameters to pass to the procedure
///
Dcl-PR json_CallPgm extproc(*CWIDEN : 'jx_callPgm');
  procedure      pointer (*PROC) value;
  parms          pointer value  ;
  numberOfParms  int(10) value  ;
End-PR;


///
// Programs and procedures : Program meta
//
// Returns the parameter meta information as a noxDb object graph accordin to the PCML format
//
// @param (input) Library where the ILE program exists or *LIBL
// @param (input) Program name of the ILE program
// @param (input) options formating and runtime options AND/added togeter
// @return noxDB object tree with output from the program call
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///

Dcl-PR json_ProgramMeta pointer extproc(*CWIDEN : 'jx_ProgramMeta');
  library        char(10) const;
  program        char(10) const;
  formatOptions  int(10) value options(*nopass) ;
End-PR;


///
// Programs and procedures : Call procedure
//
// Call ILE service program procedure compiled with ctl-opt pgminfo(*PCML:*MODULE)
//
// @param (input) Library where the ILE service program exists or *LIBL
// @param (input) service Program name
// @param (input) procedure Name of service program procedure to call
// @param (input) parms   input parameters for the program in a json object mached by names
// @param (input) options formating and runtime options AND/added togeter
// @return noxDB object tree with output from the program call
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///

Dcl-PR json_CallProcedure pointer extproc(*CWIDEN : 'jx_CallProcedure');
  library        char(10)    const;
  srvpgm         char(10)    const;
  procedure      pointer     value  options(*string);
  parms          pointer     value  options(*string:*nopass) ;
  formatOptions  int(10) value options(*nopass) ;
End-PR;


///
// Programs and procedures : Load service program procedure as procedure pointer
//
//
// @param (input) Library where the ILE service program exists or *LIBL
// @param (input) Program name of the ILE service program
// @return procedure pointer or null and wrap it in a MONITOR
//
///
Dcl-PR json_LoadServiceProgramProc pointer(*proc) extproc(*CWIDEN : 'jx_loadServiceProgramProc');
  library        char(10) const;
  program        char(10) const;
  procedure      pointer     value  options(*string);

End-PR;

///
// Programs and procedures : Call procedure - lo level
// @param (input) procedure pointer to the procedure to call
// @param (input) parms pointer to array of addresse to parameters to pass to the procedure
// @param (input) numberOfParms number of parameters to pass to the procedure
///
Dcl-PR json_CallProc extproc(*CWIDEN : 'jx_callProc');
  procedure      pointer (*PROC) value;
  parms          pointer value  ;
  numberOfParms  int(10) value  ;
End-PR;

///
// Programs and procedures : Program meta
//
// Returns the parameter meta information as a noxDb object graph according to the PCML format
//
// @param (input) Library where the ILE service program exists or *LIBL
// @param (input) service Program name
// @param (input) procedure Name of service program procedure or *ALL
// @param (input) options formating and runtime options AND/added togeter
// @return noxDB object tree with meta descript in PCML format
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///

Dcl-PR json_ProcedureMeta pointer extproc(*CWIDEN : 'jx_ProcedureMeta');
  library        char(10)  const;
  program        char(10)  const;
  procedure      pointer   value options(*string);
  formatOptions  int(10)   value options(*nopass) ;
End-PR;

///
// Programs and procedures : Program and service program meta
//
// Returns the parameter meta information as a noxDb object graph according to the PCML format
// however in a JSON  format
//
// @param (input) Library where the ILE service program exists or *LIBL
// @param (input) service Program name
// @param (input) procedure Name of service program procedure or *ALL , or *NULL for programs
// @return noxDB object tree with meta description in JSON from the PCML format
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///

Dcl-PR json_ApplicationMeta pointer extproc(*CWIDEN : 'jx_ApplicationMeta');
  library        char(10)  const;
  program        char(10)  const;
  procedure      pointer   value options(*string);
End-PR;


///
// Detect memory leak
//
// Checks if more memory has been allocated than deallocated.
//
// @return <code>*on</code> = more memory allocated than deallocated else
//         <code>*off</code>
///
Dcl-PR json_memLeak ind extproc(*CWIDEN : 'jx_MemLeak') End-PR;

///
// Print memory statistics
//
// Prints the memory statistics to the console (printf).
///
Dcl-PR json_memStat extproc(*CWIDEN : 'jx_MemStat') End-PR;

///
// Memory used
//
// Returns the number of bytes currently used by any noxDB object tree in the
// current activation group.
//
// @return Number of bytes used
///
Dcl-PR json_memUse uns(20) extproc(*CWIDEN : 'jx_MemUse') End-PR;

///
// Log message
//
// Sends an info message to the job log. The passed message can either be text
// or a node. If a node is passed it will be serialized to a JSON string before
// being sent to the job log.
//
// @param (input) Message text or node
///
Dcl-PR json_joblog extproc(*CWIDEN : 'jx_joblog');
  textOrNode pointer value options(*string);
End-PR;

///
// Execute HTTP request
//
// Executes an HTTP request. By default it will be a GET request. If a payload
// has been passed the payload will be serialized to a JSON string and the
// request will automatically be a POST request. The payload will be passed
// as unicode to cURL.
// <br><br>
// The returned JSON object contains the attribute "success" (either true or
// false) and "reason" (which contains the cURL error output (to <em>stderr</em>)
// of the request).
//
// @param (input) URL
// @param (input) HTTP request payload (object tree)
// @param (input) Extra cURL options
// @param (input) Format of the request. XML, JSON or TEXT (defaults to JSON). TEXT requires you to set the headers
// @return JSON object
//
// @info This function uses the curl command.
///
Dcl-PR json_httpRequest Pointer extproc(*CWIDEN : 'jx_httpRequest');
  url pointer value options(*string);
  payload pointer value options(*string : *nopass);
  options pointer value options(*string : *nopass);
  format  pointer value options(*string : *nopass);
End-PR;

///
// Set trace procedure
//
// Sets the trace procedure which gets called on any interaction with an
// object tree.
//
// <br/><br/>
//
// The passed procedure must implement the following interface:
// <code>
// dcl-pi *n;
//   text pointer value options(*string);
//   node pointer value;
// end-pi;
// </code>
//
// @param (input) Trace procedure
///
Dcl-PR json_setTraceProc extproc(*CWIDEN : 'jx_SetTraceProc');
  procedure pointer(*proc) value;
End-PR;


//
// SQL interface
//
// Note: When SQL functions return *NULL, then use  the json_Message() to
//       retrieve the error message.
//

///
// SQL : Set SQL options
//
// This needs to be the first call if any SQL options need to be set.
// Supported SQL options are:
//
// <h4>upperCaseColName</h4>
// <em>true</em> means that the column names in the result set are in upper
// case. Default: false.
//
// <h4>autoParseContent</h4>
// <em>true</em> means that any JSON or XML data in columns will be parsed
// into subobjects in the resulting object. Default: true.
//
// <h4>DecimalPoint</h4>
// The value of this option is used as a decimal point.
//
// <h4>sqlNaming</h4>
// <em>true</em> means that SQL Naming is used and any non qualified tables
// are searched in the current schema. <em>false</em> means that system naming
// is used and the tables are searched in the library list.
//
// @param (input) Object tree or JSON string containing SQL options or
//        <code>*null</code> to use the default options
///
Dcl-PR json_sqlSetOptions extproc(*CWIDEN : 'jx_sqlSetOptions');
  options pointer value options(*string : *nopass);
End-PR;

Dcl-PR json_sqlGetOptions varchar(32767) extproc(*CWIDEN : 'jx_sqlGetOptions');
End-PR;

///
// SQL : Set SQL root name for reultset
//
// By default the result set object will be called "rows",
// however calling this funtion will override this name
//
// @param (input) Name of the root elemt in resultsets when object are returnd
///
Dcl-PR json_sqlSetRootName extproc(*CWIDEN : 'jx_sqlSetRootName');
  rootName  pointer value options(*string);
End-PR;


///
// SQL : Execute SQL statement (single row)
//
// Returns an object node with one (first) resulting row for the SQL statment.
//
// @param (input) SQL statement
// @param (input) Template values (context)
// @param (input) Result set format options
// @return Result set or <code>*null</code> if the SELECT returns no rows
///
Dcl-PR json_sqlResultRow pointer extproc(*CWIDEN: 'jx_sqlResultRow');
  statement pointer value options(*string);
  templateValues pointer value options(*string : *nopass);
  formatOptions int(10) value options(*nopass);
End-PR;

///
// SQL : Execute SQL statement "Values"
//
// Returns an value or an array of values like the  "values into" - being array, object or value
//
// @param (input) SQL statement valid for a SET statmet
// @param (input) Template values (context)
// @param (input) Result value format options
// @return Result object of values : array, object or single values value
///
Dcl-PR json_sqlValues pointer extproc(*CWIDEN: 'jx_sqlValues');
  statement pointer value options(*string);
  templateValues pointer value options(*string : *nopass);
  formatOptions int(10) value options(*nopass);
End-PR;


///
// SQL : Execute SQL statement (multiple rows)
//
// Executes the statement and returns the result set. The result set
// structure depends on the passed options.
//
// @param (input) SQL statement
// @param (input) Start ( 1 = first (default) )
// @param (input) Max. number of rows (default: json_ALLROWS)
// @param (input) Result set format options
// @param (input) Template values (context)
// @return Result set
///
Dcl-PR json_sqlResultSet pointer extproc(*CWIDEN: 'jx_sqlResultSet');
  statement pointer value options(*string);
  start int(10) value options(*nopass);
  maxRows int(10) value options(*nopass);
  formatOptions int(10) value options(*nopass);
  templateValues pointer value options(*string : *nopass);
End-PR;

///
// All rows should be returned.
///
Dcl-C json_ALLROWS const(-1);

///
// Result set format option for returning the result set as an array with each
// row contained in a seperate object inside the returned array.
///
Dcl-C json_ROWARRAY const(0);
///
// Result set format option for additionally returning meta data with the
// result set in the property "metaData". This option triggers returning the
// result set to be an object instead of the default array.
///
Dcl-C json_META    const(1);
///
// Result set format option for additionally returning meta data about the
// table columns with the result set in the property "metaData.fields".
///
Dcl-C json_FIELDS  const(2);
///
// Result set format option for returning the total number of rows returned
// in the result set object property "totalRows".
///
Dcl-C json_TOTALROWS const(4);
///
// Result set format option for returning the column names in upper case.
///
Dcl-C json_UPPERCASE const(8);
///
// Result set format option for returning the approximate number of total
// rows in the result set object property "totalRows". This option executes
// faster than json_TOTALROWS but is not as precise.
///
Dcl-C json_APPROXIMATE_TOTALROWS const(16);
///
// Result set format option to return system column names instead of sql
// column names.
///
Dcl-C json_SYSTEM_NAMES  const(32);
///
// Result set format option to return the column names in camel case.
// "THE_COLUMN_NAME" will be returned as "theColumnName".
///
Dcl-C json_CAMEL_CASE   const(64);

///
// For SQL resultset
// If set: resultSets will return a success:false
// and set the message to the apropiate SQL error text
// If not set:  a *NULL pointer is returned and
// you have to handle the error manually
///
Dcl-C json_GRACEFUL_ERROR   const(128);

///
// Result set format option to return extra column text label
///
Dcl-C json_COLUMN_TEXT   const(256);


///
// SQL : Open SQL cursor
//
// Opens a cursor for processing the SQL data row by row.
//
// @param (input) SQL statement
// @param (input) Template values (context)
// @param (input) Result set format options
// @return SQL handle
//
// @info Any opened cursor needs to be closed with <code>jx_sqlClose</code>.
///
Dcl-PR json_sqlOpen pointer extproc(*CWIDEN :'jx_sqlOpen');
  statement pointer value options(*string);
  templateValues pointer value options(*string : *nopass);
  formatOptions int(10) value options(*nopass);
  startRow   int(10) value options(*nopass);
  limitRows  int(10) value options(*nopass);

End-PR;

///
// SQL : Fetch row at position n
//
// Returns the next row from the SQL data relative to the current cursor position.
//
// @param (input) SQL handle
// @param (input) Additional offset (relative to the current cursor)
// @return Row object or <code>*null</code> if there are no more rows to fetch
///
Dcl-PR json_sqlFetchRelative pointer extproc(*CWIDEN: 'jx_sqlFetchRelative');
  handle pointer value;
  fromRow int(10) value;
End-PR;

///
// SQL : Fetch next row
//
// Returns the next row from the SQL data.
//
// @param (input) SQL handle
// @return Row object or <code>*null</code> if there are no more rows to fetch
///
Dcl-PR json_sqlFetchNext pointer extproc(*CWIDEN : 'jx_sqlFetchNext');
  handle pointer value;
End-PR;

///
// SQL : Get number of result set columns
//
// Returns the number of columns included in the result set.
//
// @param (input) SQL handle
// @return Number of columns or -1 if an error occured
///
Dcl-PR json_sqlColumns int(10) extproc(*CWIDEN : 'jx_sqlColumns');
  handle pointer value;
End-PR;

///
// SQL : Get number of result set rows
//
// Returns the number of rows the SQL statement used by the SQL handle will
// return in total.
//
// @param (input) SQL handle
// @return Number of rows or -1 if an error occured
//
// @info This will run a hidden "select count(*)" which might be a little pricy.
///
Dcl-PR json_sqlRows int(10) extproc(*CWIDEN : 'jx_sqlRows');
  handle pointer value;
End-PR;

///
// SQL : Close SQL cursor
//
// Closes the passed SQL cursor.
//
// @param (input) SQL handle
//
// @info This function needs to be called for every SQL cursor opened with
//       <code>jx_sqlOpen</code>.
///
Dcl-PR json_sqlClose extproc(*CWIDEN : 'jx_sqlClose');
  handle pointer;
End-PR;

///
// SQL : Execute SQL statement
//
// Executes any SQL statement not involving a cursor.
//
// @param (input) SQL statement
// @param (input) Template values (context)
// @return <code>*on</code> if an error occured else <code>*off</code>
///
Dcl-PR json_sqlExec ind extproc(*CWIDEN : 'jx_sqlExec');
  statement pointer value options(*string);
  parms pointer value options(*string : *nopass);
End-PR;

///
// SQL : Call stored procedure
//
// Calls a SQL stored procedure with the passed parameters.
//
// @param (input) Qualified SQL procedure name
// @param (input) noxDB object tree with input parameters
// @return noxDB object tree with output parameters
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_sqlCall pointer extproc(*CWIDEN : 'jx_sqlCall');
  procedureName pointer value options(*string);
  inputParms pointer value;
End-PR;

///
// SQL : Call stored procedure, select from UDTF table functions, return values from scalar function
//
// Calls a SQL stored procedure / Table Function / value with the passed parameters.
//
// @param (input) Qualified SQL procedure / UDTF / value  name
// @param (input) noxDB object tree with input ( INOUT) parameters
// @param (input) Result set format options
// @return noxDB object tree with output parameters or reult set
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_sqlExecuteRoutine pointer extproc(*CWIDEN : 'jx_sqlExecuteRoutine');
  routineName     pointer value options(*string);
  parameterObject pointer value options(*nopass);
  formatOptions   int(10) value options(*nopass);
  specific        ind     value options(*nopass);
End-PR;


///
// SQL : Call stored procedure (noxDB nodes)
//
// Calls a SQL stored procedure with the passed parameters. The passed
// parameters are either JSON or XML strings or noxDB object trees. Passing
// object trees to the stored procedure lets you use these object trees
// directly in the stored procedure. A passed string will be parsed into
// a new noxDB object tree.
//
// @param (input) Qualified SQL procedure name
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @param (input) JSON or XML strings or noxDB object tree
// @return <code>*on</code> if an error occured else <code>*off</code>
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_sqlCallNode ind extproc(*CWIDEN : 'jx_sqlCallNode');
  procedureName pointer value options(*string);
  parm01 pointer value options(*string : *nopass);
  parm02 pointer value options(*string : *nopass);
  parm03 pointer value options(*string : *nopass);
  parm04 pointer value options(*string : *nopass);
  parm05 pointer value options(*string : *nopass);
  parm06 pointer value options(*string : *nopass);
  parm07 pointer value options(*string : *nopass);
  parm08 pointer value options(*string : *nopass);
  parm09 pointer value options(*string : *nopass);
  parm10 pointer value options(*string : *nopass);
End-PR;

///
// SQL : Update row
//
// Executes an UPDATE TABLE where the row is defined as an object tree.
//
// @param (input) SQL table name
// @param (input) Row data as either object tree or JSON or XML string
// @param (input) SQL WHERE clause (may include template variables like WHERE id = $id)
// @param (input) Input parameter object tree for SQL WHERE clause template variables
//        (f. e. { "id" : 123 } )
// @return <code>*on</code> if an error occured else <code>*off</code>
///
Dcl-PR json_sqlUpdate ind extproc(*CWIDEN : 'jx_sqlUpdate');
  table pointer value options(*string);
  rowData pointer value options(*string);
  where pointer value options(*string : *nopass);
  whereInputParms pointer value options(*string : *nopass);
End-PR;

///
// SQL : Insert row
//
// Executes an INSERT where the row is defined as an object tree.
//
// @param (input) SQL table name
// @param (input) Row data as either object tree or JSON or XML string
// @param (input) Input parameter (don't have to pass anything as it is not needed on INSERT)
// @return <code>*on</code> if an error occured else <code>*off</code>
///
Dcl-PR json_sqlInsert ind extproc(*CWIDEN : 'jx_sqlInsert');
  table pointer value options(*string);
  row pointer value options(*string);
  parms pointer value options(*string : *nopass);
End-PR;

///
// SQL : Upsert row
//
// Executes an UPDATE TABLE where the row is defined as an object tree if
// the table contains a row matching the passed WHERE clause. If the table
// does not contain any matching row the passed row will be INSERTed into
// the table.
//
// @param (input) SQL table name
// @param (input) Row data as either object tree or JSON or XML string
// @param (input) Input parameter (don't have to pass anything as it is not needed on INSERT)
// @return <code>*on</code> if an error occured else <code>*off</code>
//
// @info Depending on the WHERE clause more than one row may be updated by
//       this function.
///
Dcl-PR json_sqlUpsert ind extproc(*CWIDEN : 'jx_sqlUpsert');
  table pointer value options(*string);
  row pointer value options(*string);
  where pointer value options(*string : *nopass);
  whereInputParms pointer value options(*string : *nopass);
End-PR;

///
// SQL : Get last generated id
//
// Returns the last generated id (f. e. id of identity columns).
//
// @return Last generated id or 0 if there was no INSERT statement previously
//         executed
///
Dcl-PR json_sqlGetInsertId int(20) extproc(*CWIDEN : 'jx_sqlGetInsertId2');
End-PR;

///
// SQL : Get column meta data
//
// Returns an object tree (array) with column meta data. The returned array
// contains one element for each column. This element (object tree) contains
// the following attributes:
// <ul>
//  <li>name : column name</li>
//  <li>datatype : SQL datatype name (like int, varchar, timestamp)</li>
//  <li>sqltype : SQL datatype id (like 4 for int)</li>
//  <li>size : max. number of characters (not bytes)</li>
//  <li>header : column label (column header)</li>
//  <li>text   : column text label. If'text' is set in format option </li>
// </ul>
//
// @param (input) SQL SELECT statement with the columns to be queried
// @return Object tree (array) with column meta data
//
// @info The caller of this procedure needs to take care of freeing the resources
//       of the returned noxDB object tree by calling <em>jx_delete(node)</em>.
///
Dcl-PR json_sqlGetMeta pointer extproc(*CWIDEN : 'jx_sqlGetMeta');
  statement pointer value options(*string);
  formatOptions int(10) value options(*nopass);
End-PR;

///
// SQL : Connect
//
// Returns a connection object to the local database.
//
// @param (input) Options (not supported at the moment)
// @return Connection to local database
///
Dcl-PR json_sqlConnect pointer extproc(*CWIDEN : 'jx_sqlConnect');
  parms pointer value options(*string : *nopass);
End-PR;

///
// SQL : Disconnect
//
// Disconnects the current database connection.
///
Dcl-PR json_sqlDisconnect extproc(*CWIDEN : 'jx_sqlDisconnect');
End-PR;


///
// SQL : Start transaction
//
// Starts a new transaction. If commitment control has not been started yet
// it will be started now. The transaction will end on either commit or
// rollback.
//
// @return <code>*on</code> if an error occured else <code>*off</code>
//
// @info Transaction Isolation Level (Scope) will be REPEATABLE READ.
///
Dcl-PR json_sqlStartTransaction ind extproc(*CWIDEN : 'jx_sqlStartTransaction');
End-PR;

///
// SQL : Commit
//
// Commits the current transaction.
//
// @return <code>*on</code> if an error occured else <code>*off</code>
///
Dcl-PR json_sqlCommit ind extproc(*CWIDEN : 'jx_sqlCommit') End-PR;

///
// SQL : Rollback
//
// Rollbacks the current transaction.
//
// @return <code>*on</code> if an error occured else <code>*off</code>
///
Dcl-PR json_sqlRollback ind extproc(*CWIDEN : 'jx_sqlRollback') End-PR;

///
// SQL : Get last SQL code
//
// Returns the SQL code for the previous executed statement.
//
// @return SQL Code or 0 if no SQL statement was previously executed
///
Dcl-PR json_sqlCode int(10) extproc(*CWIDEN : 'jx_sqlCode') End-PR;

///
// SQL : Set trace id
//
// Sets a trace id at the current connection which will be added to the trace
// statements in the trace table.
//
// @param (input) Trace id
///
Dcl-PR json_traceSetId extproc(*CWIDEN : 'jx_traceSetId');
  traceId int(20) value;
End-PR;


//
// Deprecated and renamed functions
//

// Rather use a formatter; this is discontinued
Dcl-PR json_CloneFormat  extproc(*CWIDEN : 'jx_CloneFormat');
  //Pointer to tree to receive format
  pNode          Pointer    value;
  //node ptr or path with right formating
  pCloneFrom     Pointer    value options(*string);
End-PR;


// Depricated - use  json_GetValueStr
Dcl-PR json_GetValue Varchar(32767) extproc(*CWIDEN : 'jx_GetValueVC');
  //Pointer to node
  pNode          Pointer    value;
  //If not found - default value
  Expression     Pointer    value options(*string:*nopass);
  //If not found - default value
  Defaultvalue   Pointer    value options(*string:*nopass);
End-PR;

// Depricated - use  json_NodeCopy
Dcl-PR json_Copy extproc(*CWIDEN : 'jx_NodeCopy');
  //element. Retrive from Locate()
  pRootNode      Pointer    value;
  //element. Retrive from Locate()
  pNewChild      Pointer    value;
  //Reference location to where it arrive
  RefLocation    Int(10)    value;
End-PR;

Dcl-PR json_ElementCopy extproc(*CWIDEN : 'jx_NodeCopy');
  //element. Retrive from Locate()
  pRootNode      Pointer    value;
  //element. Retrive from Locate()
  pNewChild      Pointer    value;
  //Reference location to where it arrive
  RefLocation    Int(10)    value;
End-PR;


// Depricated - use  json_NodeDelete
Dcl-PR json_ElementDelete extproc(*CWIDEN : 'jx_NodeDelete');
  //element. Retrive from Locate()
  pRootNode      Pointer    value;
End-PR;

// Depricated - use  json_AsJsonText
Dcl-PR json_AsText Varchar(32767) extproc(*CWIDEN : 'jx_AsJsonText');
  //element. Retrive from Locate()
  pNode          Pointer    value;
End-PR;


// json_XpathValue   is depricated and replaced by: json_GetStr
Dcl-PR json_XpathValue Varchar(32767)
                     extproc(*CWIDEN : 'jx_GetValueVC');
  //Pointer to tree
  pNode          Pointer    value;
  //Locations expression to node
  Expression     Pointer    value options(*string);
  //If not found - default value
  Defaultvalue   Pointer    value options(*string:*nopass);
End-PR;

// json_XpathValueNum   is depricated and replaced by: json_GetNum
Dcl-PR json_XpathValueNum Packed(30:15)
                        extproc(*CWIDEN : 'jx_GetValueNum');
  //Pointer to tree
  pJsonCom       Pointer    value;
  //Location expression to node or attributes
  Node           Pointer    value options(*string);
  //If not found - default value
  Defaultvalue   Packed(30:15) value options(*nopass);
End-PR;

// Use - json_NodeType
Dcl-PR json_ElementType Int(5) extproc(*CWIDEN : 'jx_GetNodeType');
  //Pointer to tree to receive format
  pNode          Pointer    value;
End-PR;

// Use json_NodeAdd
// returns the new element
Dcl-PR json_ElementAdd Pointer extproc(*CWIDEN : 'jx_NodeAdd');
  //element. Retrive from Locate()
  pRootNode      Pointer    value;
  //Reference location to where it arrive
  RefLocation    Int(10)    value;
  //Name of element
  Name           Pointer    value options(*string);
  //Value of element
  Value          Pointer    value options(*string);
End-PR;

// Use json_GetNext
// Returns pointer to next sibling (elem)
Dcl-PR json_GetElemNext Pointer extproc(*CWIDEN : 'jx_GetNodeNext');
  //Pointer to current element (elem)
  pElem          Pointer    value  ;
End-PR;

// use json_GetChild
// Returns pointer to next child (elem)
Dcl-PR json_GetElemChild Pointer extproc(*CWIDEN : 'jx_GetNodeChild');
  //Pointer to current element (elem)
  pElem          Pointer    value;
End-PR;


// use get json_GetName
Dcl-PR json_getElemName Varchar(32767)
                      extproc(*CWIDEN : 'jx_GetNodeNameVC');
  //Pointer to node
  pNode          Pointer    value;
End-PR;

// use xml_GetValueStr
Dcl-PR json_GetElemValue Varchar(32767)
                       extproc(*CWIDEN : 'jx_GetNodeValueVC');
  //Pointer to element
  pElem          Pointer    value;
  //If not found - default value
  Defaultvalue   Pointer    value options(*string:*nopass);
End-PR;

// use json_GetAttrValue
Dcl-PR json_GetAttr Varchar(32767)
                  extproc(*CWIDEN : 'jx_GetNodeAttrValueVC');
  //Pointer to element
  pNode          Pointer    value;
  //Attribute Name
  AttrName       Pointer    value options(*string);
  //If not found - default value
  Defaultvalue   Pointer    value options(*string:*nopass);
End-PR;

// has no effect any longer
// Set input and output CCSID
Dcl-PR json_setCcsid  extproc(*CWIDEN : 'jx_SetCcsid');
  //Ccsid of inpur file
  inputCCSID     Int(10)    value;
  //Ccsid of output file
  outputCCSID    Int(10)    value;
End-PR;

// depricated - use setNum
Dcl-PR json_SetDec Pointer extproc(*CWIDEN: 'jx_SetDecByName');
  //Pointer to json_ tree
  pNode          Pointer    value;
  //Location expression to node or attributes
  Expresion      Pointer    value options(*string);
  //New value to set / pointer to object
  Value          Packed(30:15) value;
End-PR;

// Depricated in both JSON and XML - use  json_WriteJsonStmf /   json_WriteXmlStmf
/if not defined(JSONXML_DEPRICATED)
/define  JSONXML_DEPRICATED
Dcl-PR json_WriteStmf  extproc(*CWIDEN : 'jx_WriteJsonStmf');
  //element. Retrive from Locate()
  pNode          Pointer    value;
  //Name of output stream file
  FileName       Pointer    value options(*string);
  //Ccsid of output file
  Ccsid          Int(10)    value;
  Trim           Ind        value options(*nopass);
End-PR;

Dcl-PR xml_WriteStmf  extproc(*CWIDEN : 'jx_WriteXmlStmf');
  //element. Retrive from Locate()
  pNode          Pointer    value;
  //Name of output stream file
  FileName       Pointer    value options(*string);
  //Ccsid of output file
  Ccsid          Int(10)    value;
  Trim           Ind        value options(*nopass);
End-PR;
/endif

// Need Space arround the json_OVERLOAD , else the prototype generator will not work
/if defined( json_OVERLOAD )
///
// Set value
//
// Sets the passed value to the node pointed to by the passed path expression.
// This is an overloaded function and proxies calls to one of the following
// functions depending on the passed parameters.
//
// <ul>
//   <li>jx_setBool</li>
//   <li>jx_setNum</li>
//   <li>jx_setInt</li>
//   <li>jx_setDate</li>
//   <li>jx_setTime</li>
//   <li>jx_setTimestamp</li>
//   <li>jx_setStr</li>
// </ul>
// Note: setBool will have same signature as setStr and setInt will have same
// signature that setNum so they are omitted for now
//
// @param (input) Node
// @param (input) Node path expression
// @param (input) New value
// @return Changed node
///
Dcl-PR json_set pointer overload (
//  json_setBool:
    json_setNum :
//  json_setInt :
    json_setDate:
    json_setTime:
    json_setTimeStamp:
    json_setStr
);
/endif
